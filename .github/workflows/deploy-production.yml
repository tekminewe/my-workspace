# name: Deploy to Production

# on:
#   push:
#     branches: [main]
#     tags: ['v*']
#   workflow_dispatch:
#     inputs:
#       environment:
#         description: 'Deployment environment'
#         required: true
#         default: 'production'
#         type: choice
#         options:
#           - production
#           - hotfix
#       skip_tests:
#         description: 'Skip integration tests (emergency deployments only)'
#         required: false
#         default: false
#         type: boolean

# concurrency:
#   group: production-deploy
#   cancel-in-progress: false

# jobs:
#   # Pre-deployment validation
#   pre-deploy-validation:
#     runs-on: ubuntu-latest
#     outputs:
#       deploy-service: ${{ steps.changes.outputs.my-service }}
#       deploy-web: ${{ steps.changes.outputs.my-web }}
#       deploy-functions: ${{ steps.changes.outputs.my-functions }}
#       version: ${{ steps.version.outputs.version }}

#     steps:
#       - uses: actions/checkout@v4
#         with:
#           fetch-depth: 0

#       - name: Get version
#         id: version
#         run: |
#           if [[ $GITHUB_REF == refs/tags/* ]]; then
#             VERSION=${GITHUB_REF#refs/tags/}
#           else
#             VERSION="main-$(date +%Y%m%d)-${GITHUB_SHA:0:7}"
#           fi
#           echo "version=$VERSION" >> $GITHUB_OUTPUT

#       - uses: dorny/paths-filter@v3
#         id: changes
#         with:
#           base: ${{ github.event.before }}
#           filters: |
#             my-service:
#               - 'my-service/**'
#             my-web:
#               - 'my-web/**'
#             my-functions:
#               - 'my-functions/**'

#       - name: Validate deployment readiness
#         run: |
#           echo "üîç Validating deployment for version: ${{ steps.version.outputs.version }}"
#           echo "üì¶ Service changes: ${{ steps.changes.outputs.my-service }}"
#           echo "üåê Web changes: ${{ steps.changes.outputs.my-web }}"
#           echo "‚ö° Functions changes: ${{ steps.changes.outputs.my-functions }}"

#   # Run comprehensive tests before production deployment
#   pre-deploy-tests:
#     runs-on: ubuntu-latest
#     if: github.event.inputs.skip_tests != 'true'

#     services:
#       postgres:
#         image: postgres:15
#         env:
#           POSTGRES_DB: test
#           POSTGRES_USER: test
#           POSTGRES_PASSWORD: test
#         options: >-
#           --health-cmd pg_isready
#           --health-interval 10s
#           --health-timeout 5s
#           --health-retries 5
#         ports:
#           - 5432:5432

#     steps:
#       - uses: actions/checkout@v4

#       - name: Setup Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: '20'

#       - name: Setup pnpm
#         uses: pnpm/action-setup@v4
#         with:
#           version: latest

#       # Run full test suite
#       - name: Install and test my-service
#         working-directory: ./my-service
#         run: |
#           pnpm install --frozen-lockfile
#           pnpm gen:prisma
#           pnpm prisma migrate deploy
#           pnpm test
#           pnpm test:e2e || echo "E2E tests not available"
#         env:
#           DATABASE_URL: postgresql://test:test@localhost:5432/test

#       - name: Install and test my-web
#         working-directory: ./my-web
#         run: |
#           pnpm install --frozen-lockfile
#           pnpm gen:graphql
#           pnpm test || echo "Tests not available"
#           pnpm build
#         env:
#           NEXT_TELEMETRY_DISABLED: 1

#   # Deploy my-service to production
#   deploy-service-prod:
#     needs: [pre-deploy-validation, pre-deploy-tests]
#     if: always() && needs.pre-deploy-validation.outputs.deploy-service == 'true' && (needs.pre-deploy-tests.result == 'success' || needs.pre-deploy-tests.result == 'skipped')
#     runs-on: ubuntu-latest
#     environment: production

#     steps:
#       - uses: actions/checkout@v4

#       - name: Configure AWS credentials
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

#       - name: Login to Amazon ECR
#         id: login-ecr
#         uses: aws-actions/amazon-ecr-login@v2

#       - name: Build and push production image
#         working-directory: ./my-service
#         env:
#           ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
#           ECR_REPOSITORY: my-service-prod
#           IMAGE_TAG: ${{ needs.pre-deploy-validation.outputs.version }}
#         run: |
#           docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
#           docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
#           docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
#           docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

#       - name: Update production ECS service
#         env:
#           ECS_CLUSTER: my-workspace-prod
#           ECS_SERVICE: my-service-prod
#           IMAGE_URI: ${{ steps.login-ecr.outputs.registry }}/my-service-prod:${{ needs.pre-deploy-validation.outputs.version }}
#         run: |
#           # Create deployment with blue-green strategy
#           TASK_DEFINITION=$(aws ecs describe-task-definition --task-definition $ECS_SERVICE --query 'taskDefinition' --output json)
#           NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "$IMAGE_URI" '.containerDefinitions[0].image = $IMAGE')
#           NEW_TASK_DEFINITION=$(echo $NEW_TASK_DEFINITION | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)')

#           aws ecs register-task-definition --cli-input-json "$NEW_TASK_DEFINITION"

#           # Update service with deployment configuration
#           aws ecs update-service \
#             --cluster $ECS_CLUSTER \
#             --service $ECS_SERVICE \
#             --task-definition $ECS_SERVICE \
#             --deployment-configuration maximumPercent=200,minimumHealthyPercent=100

#           # Wait for stable deployment
#           echo "Waiting for deployment to stabilize..."
#           aws ecs wait services-stable --cluster $ECS_CLUSTER --services $ECS_SERVICE --cli-read-timeout 600

#           echo "‚úÖ Service deployed successfully"

#   # Deploy my-web to production
#   deploy-web-prod:
#     needs: [pre-deploy-validation, pre-deploy-tests]
#     if: always() && needs.pre-deploy-validation.outputs.deploy-web == 'true' && (needs.pre-deploy-tests.result == 'success' || needs.pre-deploy-tests.result == 'skipped')
#     runs-on: ubuntu-latest
#     environment: production

#     steps:
#       - uses: actions/checkout@v4

#       - name: Setup Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: '20'

#       - name: Setup pnpm
#         uses: pnpm/action-setup@v4
#         with:
#           version: latest

#       - name: Install Vercel CLI
#         run: npm install -g vercel@latest

#       - name: Pull Vercel environment
#         working-directory: ./my-web
#         run: vercel pull --yes --environment=production --token=${{ secrets.VERCEL_TOKEN }}

#       - name: Build project artifacts
#         working-directory: ./my-web
#         run: vercel build --token=${{ secrets.VERCEL_TOKEN }} --prod
#         env:
#           NEXT_TELEMETRY_DISABLED: 1

#       - name: Deploy to production
#         working-directory: ./my-web
#         run: |
#           DEPLOYMENT_URL=$(vercel deploy --prebuilt --prod --token=${{ secrets.VERCEL_TOKEN }} | tail -n 1)
#           echo "deployment-url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
#           echo "‚úÖ Web deployed successfully to: $DEPLOYMENT_URL"
#         id: deploy

#   # Deploy my-functions to production
#   deploy-functions-prod:
#     needs: [pre-deploy-validation, pre-deploy-tests]
#     if: always() && needs.pre-deploy-validation.outputs.deploy-functions == 'true' && (needs.pre-deploy-tests.result == 'success' || needs.pre-deploy-tests.result == 'skipped')
#     runs-on: ubuntu-latest
#     environment: production

#     steps:
#       - uses: actions/checkout@v4

#       - name: Setup Python
#         uses: actions/setup-python@v5
#         with:
#           python-version: '3.11'

#       - name: Setup SAM CLI
#         uses: aws-actions/setup-sam@v2
#         with:
#           use-installer: true

#       - name: Configure AWS credentials
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

#       - name: Build and deploy Lambda functions
#         working-directory: ./my-functions
#         run: |
#           sam build
#           sam deploy \
#             --config-env production \
#             --no-confirm-changeset \
#             --no-fail-on-empty-changeset \
#             --parameter-overrides Environment=production Version=${{ needs.pre-deploy-validation.outputs.version }}

#           echo "‚úÖ Functions deployed successfully"

#   # Post-deployment verification
#   post-deploy-verification:
#     needs: [deploy-service-prod, deploy-web-prod, deploy-functions-prod]
#     if: always() && (needs.deploy-service-prod.result == 'success' || needs.deploy-web-prod.result == 'success' || needs.deploy-functions-prod.result == 'success')
#     runs-on: ubuntu-latest
#     environment: production

#     steps:
#       - name: Health check production services
#         env:
#           PROD_API_URL: ${{ vars.PROD_API_URL }}
#           PROD_WEB_URL: ${{ vars.PROD_WEB_URL }}
#         run: |
#           echo "üîç Verifying production deployment..."

#           # Wait for services to be ready
#           sleep 30

#           # Check API health
#           if [ ! -z "$PROD_API_URL" ]; then
#             echo "Checking API health..."
#             for i in {1..5}; do
#               if curl -f "$PROD_API_URL/health"; then
#                 echo "‚úÖ API health check passed"
#                 break
#               fi
#               if [ $i -eq 5 ]; then
#                 echo "‚ùå API health check failed after 5 attempts"
#                 exit 1
#               fi
#               sleep 10
#             done
#           fi

#           # Check web health
#           if [ ! -z "$PROD_WEB_URL" ]; then
#             echo "Checking web health..."
#             for i in {1..5}; do
#               if curl -f "$PROD_WEB_URL"; then
#                 echo "‚úÖ Web health check passed"
#                 break
#               fi
#               if [ $i -eq 5 ]; then
#                 echo "‚ùå Web health check failed after 5 attempts"
#                 exit 1
#               fi
#               sleep 10
#             done
#           fi

#           echo "üéâ All production health checks passed!"

#   # Create GitHub release for tagged deployments
#   create-release:
#     needs: [pre-deploy-validation, post-deploy-verification]
#     if: startsWith(github.ref, 'refs/tags/') && needs.post-deploy-verification.result == 'success'
#     runs-on: ubuntu-latest

#     steps:
#       - uses: actions/checkout@v4
#         with:
#           fetch-depth: 0

#       - name: Generate changelog
#         id: changelog
#         run: |
#           if [ -f CHANGELOG.md ]; then
#             # Extract changelog for current version
#             VERSION=${{ needs.pre-deploy-validation.outputs.version }}
#             CHANGELOG=$(awk "/^## \[$VERSION\]/{flag=1; next} /^## \[/{flag=0} flag" CHANGELOG.md || echo "No changelog available for this version.")
#           else
#             # Generate simple changelog from commits
#             CHANGELOG=$(git log --pretty=format:"- %s (%an)" $(git describe --tags --abbrev=0 HEAD^)..HEAD 2>/dev/null || echo "- Initial release")
#           fi

#           echo "changelog<<EOF" >> $GITHUB_OUTPUT
#           echo "$CHANGELOG" >> $GITHUB_OUTPUT
#           echo "EOF" >> $GITHUB_OUTPUT

#       - name: Create GitHub release
#         uses: actions/create-release@v1
#         env:
#           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#         with:
#           tag_name: ${{ needs.pre-deploy-validation.outputs.version }}
#           release_name: Release ${{ needs.pre-deploy-validation.outputs.version }}
#           body: |
#             ## üöÄ Production Deployment

#             **Version**: ${{ needs.pre-deploy-validation.outputs.version }}
#             **Deployed**: ${{ github.event.head_commit.timestamp }}
#             **Commit**: ${{ github.sha }}

#             ### Changes
#             ${{ steps.changelog.outputs.changelog }}

#             ### Deployment Status
#             - ‚úÖ Service: ${{ needs.deploy-service-prod.result }}
#             - ‚úÖ Web: ${{ needs.deploy-web-prod.result }}
#             - ‚úÖ Functions: ${{ needs.deploy-functions-prod.result }}
#             - ‚úÖ Health Checks: ${{ needs.post-deploy-verification.result }}
#           draft: false
#           prerelease: false

#   # Notification and rollback preparation
#   deployment-notification:
#     needs:
#       [
#         pre-deploy-validation,
#         deploy-service-prod,
#         deploy-web-prod,
#         deploy-functions-prod,
#         post-deploy-verification,
#       ]
#     if: always()
#     runs-on: ubuntu-latest

#     steps:
#       - name: Deployment summary
#         uses: actions/github-script@v7
#         with:
#           script: |
#             const version = '${{ needs.pre-deploy-validation.outputs.version }}';
#             const results = {
#               'Service': '${{ needs.deploy-service-prod.result }}',
#               'Web': '${{ needs.deploy-web-prod.result }}',
#               'Functions': '${{ needs.deploy-functions-prod.result }}',
#               'Health Checks': '${{ needs.post-deploy-verification.result }}'
#             };

#             const statusEmoji = {
#               'success': '‚úÖ',
#               'failure': '‚ùå',
#               'cancelled': '‚ö†Ô∏è',
#               'skipped': '‚è≠Ô∏è'
#             };

#             let hasFailures = false;
#             let summary = `## üöÄ Production Deployment: ${version}\n\n`;

#             for (const [component, result] of Object.entries(results)) {
#               if (result !== 'skipped') {
#                 summary += `${statusEmoji[result] || '‚ùì'} **${component}**: ${result}\n`;
#                 if (result === 'failure') hasFailures = true;
#               }
#             }

#             if (hasFailures) {
#               summary += '\n‚ö†Ô∏è **Some components failed to deploy. Consider rollback if critical.**';
#             } else if (Object.values(results).some(r => r === 'success')) {
#               summary += '\nüéâ **Production deployment completed successfully!**';
#             }

#             summary += `\n\n**Version**: ${version}`;
#             summary += `\n**Commit**: ${context.sha.substring(0, 7)}`;
#             summary += `\n**Triggered by**: ${context.actor}`;
#             summary += `\n**Timestamp**: ${new Date().toISOString()}`;

#             console.log(summary);

#             // Set job summary
#             core.summary.addRaw(summary);
#             await core.summary.write();

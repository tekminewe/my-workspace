# name: Deploy to Staging

# on:
#   push:
#     branches: [develop]
#   workflow_dispatch:
#     inputs:
#       force_deploy:
#         description: 'Force deployment even if no changes detected'
#         required: false
#         default: false
#         type: boolean

# concurrency:
#   group: staging-deploy-${{ github.ref }}
#   cancel-in-progress: false

# jobs:
#   # Build and test before deployment
#   pre-deploy:
#     runs-on: ubuntu-latest
#     outputs:
#       my-service-changed: ${{ steps.changes.outputs.my-service }}
#       my-web-changed: ${{ steps.changes.outputs.my-web }}
#       my-functions-changed: ${{ steps.changes.outputs.my-functions }}

#     steps:
#       - uses: actions/checkout@v4
#         with:
#           fetch-depth: 2

#       - uses: dorny/paths-filter@v3
#         id: changes
#         with:
#           filters: |
#             my-service:
#               - 'my-service/**'
#             my-web:
#               - 'my-web/**'
#             my-functions:
#               - 'my-functions/**'

#       - name: Setup Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: '20'

#       - name: Setup pnpm
#         uses: pnpm/action-setup@v4
#         with:
#           version: latest

#       # Quick smoke tests before deployment
#       - name: Quick build test (my-service)
#         if: steps.changes.outputs.my-service == 'true' || github.event.inputs.force_deploy == 'true'
#         working-directory: ./my-service
#         run: |
#           pnpm install --frozen-lockfile
#           pnpm gen:prisma
#           pnpm build

#       - name: Quick build test (my-web)
#         if: steps.changes.outputs.my-web == 'true' || github.event.inputs.force_deploy == 'true'
#         working-directory: ./my-web
#         run: |
#           pnpm install --frozen-lockfile
#           pnpm gen:graphql
#           pnpm build
#         env:
#           NEXT_TELEMETRY_DISABLED: 1

#   # Deploy my-service to staging (ECS)
#   deploy-service:
#     needs: pre-deploy
#     if: needs.pre-deploy.outputs.my-service-changed == 'true' || github.event.inputs.force_deploy == 'true'
#     runs-on: ubuntu-latest
#     environment: staging

#     steps:
#       - uses: actions/checkout@v4

#       - name: Configure AWS credentials
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

#       - name: Login to Amazon ECR
#         id: login-ecr
#         uses: aws-actions/amazon-ecr-login@v2

#       - name: Build and push Docker image
#         working-directory: ./my-service
#         env:
#           ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
#           ECR_REPOSITORY: my-service-staging
#           IMAGE_TAG: ${{ github.sha }}
#         run: |
#           docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
#           docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
#           echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

#       - name: Update ECS service
#         env:
#           ECS_CLUSTER: my-workspace-staging
#           ECS_SERVICE: my-service-staging
#           CONTAINER_NAME: my-service
#           IMAGE_URI: ${{ steps.login-ecr.outputs.registry }}/my-service-staging:${{ github.sha }}
#         run: |
#           # Get current task definition
#           TASK_DEFINITION=$(aws ecs describe-task-definition --task-definition $ECS_SERVICE --query 'taskDefinition' --output json)

#           # Update image in task definition
#           NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "$IMAGE_URI" '.containerDefinitions[0].image = $IMAGE')

#           # Remove unnecessary fields
#           NEW_TASK_DEFINITION=$(echo $NEW_TASK_DEFINITION | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)')

#           # Register new task definition
#           aws ecs register-task-definition --cli-input-json "$NEW_TASK_DEFINITION"

#           # Update service
#           aws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE --task-definition $ECS_SERVICE

#           # Wait for deployment to complete
#           aws ecs wait services-stable --cluster $ECS_CLUSTER --services $ECS_SERVICE

#   # Deploy my-web to staging (Vercel)
#   deploy-web:
#     needs: pre-deploy
#     if: needs.pre-deploy.outputs.my-web-changed == 'true' || github.event.inputs.force_deploy == 'true'
#     runs-on: ubuntu-latest
#     environment: staging

#     steps:
#       - uses: actions/checkout@v4

#       - name: Setup Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: '20'

#       - name: Setup pnpm
#         uses: pnpm/action-setup@v4
#         with:
#           version: latest

#       - name: Install Vercel CLI
#         run: npm install -g vercel@latest

#       - name: Pull Vercel environment
#         working-directory: ./my-web
#         run: vercel pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}

#       - name: Build project artifacts
#         working-directory: ./my-web
#         run: vercel build --token=${{ secrets.VERCEL_TOKEN }}
#         env:
#           NEXT_TELEMETRY_DISABLED: 1

#       - name: Deploy to Vercel
#         working-directory: ./my-web
#         run: |
#           DEPLOYMENT_URL=$(vercel deploy --prebuilt --token=${{ secrets.VERCEL_TOKEN }} | tail -n 1)
#           echo "deployment-url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
#         id: deploy

#       - name: Comment deployment URL
#         uses: actions/github-script@v7
#         with:
#           script: |
#             if (context.eventName === 'push') {
#               const { data: commits } = await github.rest.repos.listCommits({
#                 owner: context.repo.owner,
#                 repo: context.repo.repo,
#                 sha: context.sha,
#                 per_page: 1
#               });

#               if (commits.length > 0) {
#                 await github.rest.repos.createCommitComment({
#                   owner: context.repo.owner,
#                   repo: context.repo.repo,
#                   commit_sha: context.sha,
#                   body: `üöÄ **Staging Deployment**\n\n‚úÖ Successfully deployed to staging: ${{ steps.deploy.outputs.deployment-url }}`
#                 });
#               }
#             }

#   # Deploy my-functions to staging (AWS Lambda)
#   deploy-functions:
#     needs: pre-deploy
#     if: needs.pre-deploy.outputs.my-functions-changed == 'true' || github.event.inputs.force_deploy == 'true'
#     runs-on: ubuntu-latest
#     environment: staging

#     steps:
#       - uses: actions/checkout@v4

#       - name: Setup Python
#         uses: actions/setup-python@v5
#         with:
#           python-version: '3.11'

#       - name: Setup SAM CLI
#         uses: aws-actions/setup-sam@v2
#         with:
#           use-installer: true

#       - name: Configure AWS credentials
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

#       - name: Build SAM application
#         working-directory: ./my-functions
#         run: sam build

#       - name: Deploy to staging
#         working-directory: ./my-functions
#         run: |
#           sam deploy \
#             --config-env staging \
#             --no-confirm-changeset \
#             --no-fail-on-empty-changeset \
#             --parameter-overrides Environment=staging

#   # Run integration tests against staging
#   integration-tests:
#     needs: [deploy-service, deploy-web, deploy-functions]
#     if: always() && (needs.deploy-service.result == 'success' || needs.deploy-web.result == 'success' || needs.deploy-functions.result == 'success')
#     runs-on: ubuntu-latest
#     environment: staging

#     steps:
#       - uses: actions/checkout@v4

#       - name: Setup Node.js
#         uses: actions/setup-node@v4
#         with:
#           node-version: '20'

#       - name: Run health checks
#         env:
#           STAGING_API_URL: ${{ vars.STAGING_API_URL }}
#           STAGING_WEB_URL: ${{ vars.STAGING_WEB_URL }}
#         run: |
#           echo "Running health checks against staging environment..."

#           # Check API health
#           if [ ! -z "$STAGING_API_URL" ]; then
#             echo "Checking API health at $STAGING_API_URL/health"
#             curl -f "$STAGING_API_URL/health" || exit 1
#           fi

#           # Check web health
#           if [ ! -z "$STAGING_WEB_URL" ]; then
#             echo "Checking web health at $STAGING_WEB_URL"
#             curl -f "$STAGING_WEB_URL" || exit 1
#           fi

#           echo "All health checks passed!"

#   # Notify deployment status
#   notify:
#     needs: [deploy-service, deploy-web, deploy-functions, integration-tests]
#     if: always()
#     runs-on: ubuntu-latest

#     steps:
#       - name: Deployment summary
#         uses: actions/github-script@v7
#         with:
#           script: |
#             const results = {
#               'Service': '${{ needs.deploy-service.result }}',
#               'Web': '${{ needs.deploy-web.result }}',
#               'Functions': '${{ needs.deploy-functions.result }}',
#               'Integration Tests': '${{ needs.integration-tests.result }}'
#             };

#             const statusEmoji = {
#               'success': '‚úÖ',
#               'failure': '‚ùå',
#               'cancelled': '‚ö†Ô∏è',
#               'skipped': '‚è≠Ô∏è'
#             };

#             let summary = '## üöÄ Staging Deployment Summary\n\n';
#             for (const [component, result] of Object.entries(results)) {
#               if (result !== 'skipped') {
#                 summary += `${statusEmoji[result] || '‚ùì'} **${component}**: ${result}\n`;
#               }
#             }

#             summary += `\n**Commit**: ${context.sha.substring(0, 7)}`;
#             summary += `\n**Branch**: ${context.ref.replace('refs/heads/', '')}`;
#             summary += `\n**Triggered by**: ${context.actor}`;

#             console.log(summary);
